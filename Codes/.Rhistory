#' @param data.testS4
#' @param classts
#' @param tL tune Length
#' @param n number of CV
#' @param r number of repeats for CV
#' @returns A list of Confusion Matrices one for each pls-based method
pls.based <- function(data.trainS4, data.testS4, classts,
tL = 5, n = 5, r = 5){
library(gpls)
# Define control function for all sparse.based classifiers
plsControl <- trainControl(method = "repeatedcv", number = n,
repeats = r, classProbs = TRUE)
print("Fitting gpls")
set.seed(1510)
# generalized partial least squares
fit.gpls <- classify(data = data.trainS4, method = "gpls",
preProcessing = "deseq-vst", ref = "D", tuneLength = tL,
control = plsControl)
#Predicted class labels
pred.gpls <- predict(fit.gpls, data.testS4)
pred.gpls <- relevel(pred.gpls, ref = "D")
actual <- relevel(classts$condition, ref = "D")
tblgpls <- table(Predicted = pred.gpls, Actual = actual)
gpls.cm <- confusionMatrix(tblgpls, positive = "D")
# compute elbow genes
coeff_gpls <- abs(fit.gpls@modelInfo@trainedModel[["finalModel"]][["coefficients"]][-1])
genes_gpls_plsBased <- list(elbow_comp(coefficients = coeff_gpls))
print("Fitting pls")
set.seed(1510)
# partial least squares
fit.pls <- classify(data = data.trainS4, method = "pls",
preProcessing = "deseq-vst", ref = "D", tuneLength = tL,
control = plsControl)
#Predicted class labels
pred.pls <- predict(fit.pls, data.testS4)
pred.pls <- relevel(pred.pls, ref = "D")
tblpls <- table(Predicted = pred.pls, Actual = actual)
pls.cm <- confusionMatrix(tblpls, positive = "D")
# compute elbow genes
# coeff_pls <- abs(fit.pls@modelInfo@trainedModel[["finalModel"]][["coefficients"]][,1,2])
# genes_pls_plsBased <- list(elbow_comp(coefficients = coeff_pls))
genes_pls_plsBased <- list(c("ADA", "Gino"))
print("Fitting SPLS")
set.seed(1510)
# Sparse partial least squares
fit.spls <- classify(data = data.trainS4, method = "spls",
preProcessing = "deseq-vst", ref = "D", tuneLength = tL,
control = plsControl)
#Predicted class labels
pred.spls <- predict(fit.spls, data.testS4)
pred.spls <- relevel(pred.spls, ref = "D")
tblspls <- table(Predicted = pred.spls, Actual = actual)
spls.cm <- confusionMatrix(tblspls, positive = "D")
# compute elbow genes
coeff_spls <- abs(fit.spls@modelInfo@trainedModel[["finalModel"]][["normx"]])
genes_spls_plsBased <- list(elbow_comp(coefficients = coeff_spls))
print("Successfully accomplished pls-based methods")
return(list(gpls.cm, pls.cm, spls.cm,
genes_gpls_plsBased, genes_pls_plsBased, genes_spls_plsBased))
}
dfsImport <- dfs.import()
df <- dfsImport[[1]]
#df <- df[1:1500, ]
class <- dfsImport[[2]]
keep <- rowSums(df > 10) > round(ncol(df)/3)
df <- df[keep, ]
seed=123
crossVal.1layer <- function(seed, i, mincorr = 0.3){
tts <- trainTest.split(df, class, mincorr = mincorr, seed = seed)
data.trainS4 <- tts[[1]]
data.testS4 <- tts[[2]]
classts <- tts[[3]]
# mini-check per vedere se i geni filtati sono gli stessi
print(sum(rownames(assay(data.trainS4)) == rownames(assay(data.testS4))))
svm <- svm.based(data.trainS4, data.testS4, classts)
svmRadial <- svm[[1]]
svmPoly <- svm[[2]]
svmLinear <- svm[[3]]
genes_svmRadial_SVMBased <- svm[[4]]
genes_svmPoly_SVMBased <- svm[[5]]
genes_svmLinear_SVMBased <- svm[[6]]
voom <- voom.based(data.trainS4, data.testS4, classts)
voomDLDA <- voom[[1]]
voomDQDA <- voom[[2]]
voomNSC <- voom[[3]]
genes_voomDLDA_voomBased <- voom[[4]]
genes_voomDQDA_voomBased <- voom[[5]]
genes_voomNSC_voomBased <- voom[[6]]
lin <- linear.based(data.trainS4, data.testS4, classts)
PLDA <- lin[[1]]
PLDA2 <- lin[[2]]
NBLDA <- lin[[3]]
genes_PLDA_LDABased <- lin[[4]]
genes_PLDA2_LDABased <- lin[[5]]
sparse <- sparse.based(data.trainS4, data.testS4, classts) # <-- too slow!!
sparseLDA <- sparse[[1]]
genes_sparseLDA_LDABased <- sparse[[2]]
# net <- nnet.based(data.trainS4, data.testS4, classts) # <-- not properly working!!
# #nnet <- net[[1]]
# mlp <- net[[2]]
# mlpML <- net[[3]]
# #avNNet <- net[[4]]
tree <- tree.based(data.trainS4, data.testS4, classts)
rpart <- tree[[1]]
cforest <- tree[[2]]
ctree <- tree[[3]]
rf <- tree[[4]]
genes_rpart_treeBased <- tree[[5]]
genes_cforest_treeBased <- tree[[6]]
genes_ctree_treeBased <- tree[[7]]
genes_rf_treeBased <- tree[[8]]
bag <- bagg.based(data.trainS4, data.testS4, classts)
AdaBag <- bag[[1]]
treebag <- bag[[2]]
bagFDA <- bag[[3]]
genes_AdaBag_baggedBased <- bag[[4]]
genes_treebag_baggedBased <- bag[[5]]
bst <- boost.based(data.trainS4, data.testS4, classts)
gamboost <- bst[[1]]
bstSm <- bst[[2]]
bstTree <- bst[[3]]
genes_gamboost_boostBased <- bst[[4]]
genes_gamboost_boostBased[[1]] <- sub("bbs\\(([^,]+),.*", "\\1", genes_gamboost_boostBased[[1]])
genes_bstSm_boostBased <- bst[[5]]
genes_bstTree_boostBased <- bst[[6]]
partls <- pls.based(data.trainS4, data.testS4, classts)
gpls <- partls[[1]]
pls <- partls[[2]]
spls <- partls[[3]]
genes_gpls_plsBased <- partls[[4]]
# genes_pls_plsBased <- partls[[5]]
genes_spls_plsBased <- partls[[6]]
acc.df <- data.frame(svmRadial = c(svmRadial$overall, svmRadial$byClass),
svmPoly = c(svmPoly$overall, svmPoly$byClass),
svmLinear = c(svmLinear$overall, svmLinear$byClass),
voomDLDA = c(voomDLDA$overall, voomDLDA$byClass),
voomDQDA = c(voomDQDA$overall, voomDQDA$byClass),
voomNSC = c(voomNSC$overall, voomNSC$byClass),
PLDA = c(PLDA$overall, PLDA$byClass),
PLDA2 = c(PLDA2$overall, PLDA2$byClass),
NBLDA = c(NBLDA$overall, NBLDA$byClass),
sparseLDA = c(sparseLDA$overall, sparseLDA$byClass),
# nnet = c(nnet$overall, nnet$byClass),
# mlp = c(mlp$overall, mlp$byClass),
# mlpML = c(mlpML$overall, mlpML$byClass),
# avNNet = c(avNNet$overall, avNNet$byClass),
rpart = c(rpart$overall, rpart$byClass),
cforest = c(cforest$overall, cforest$byClass),
ctree = c(ctree$overall, ctree$byClass),
rf = c(rf$overall, rf$byClass),
AdaBag = c(AdaBag$overall, AdaBag$byClass),
treebag = c(treebag$overall, treebag$byClass),
bagFDA = c(bagFDA$overall, bagFDA$byClass),
gamboost = c(gamboost$overall, gamboost$byClass),
bstSm = c(bstSm$overall, bstSm$byClass),
bstTree = c(bstTree$overall, bstTree$byClass),
gpls = c(gpls$overall, gpls$byClass),
pls = c(pls$overall, pls$byClass),
spls = c(spls$overall, spls$byClass))
#i=1
write.csv2(t(acc.df), paste0("../Results/AccuracyTable_",i,".csv"))
list_genes <- list(genes_svmRadial_SVMBased = genes_svmRadial_SVMBased[[1]],
genes_svmPoly_SVMBased = genes_svmPoly_SVMBased[[1]],
genes_svmLinear_SVMBased = genes_svmLinear_SVMBased[[1]],
genes_voomDLDA_voomBased = genes_voomDLDA_voomBased[[1]],
genes_voomDQDA_voomBased = genes_voomDQDA_voomBased[[1]],
genes_voomNSC_voomBased = genes_voomNSC_voomBased[[1]],
genes_PLDA_LDABased = genes_PLDA_LDABased[[1]],
genes_PLDA2_LDABased = genes_PLDA2_LDABased[[1]],
genes_sparseLDA_LDABased = genes_sparseLDA_LDABased[[1]],
genes_rpart_treeBased = names(genes_rpart_treeBased[[1]]),
genes_cforest_treeBased = genes_cforest_treeBased[[1]],
genes_ctree_treeBased = genes_ctree_treeBased[[1]],
genes_rf_treeBased = genes_rf_treeBased[[1]],
genes_AdaBag_baggedBased = names(genes_AdaBag_baggedBased[[1]][genes_AdaBag_baggedBased[[1]]>0]),
genes_treebag_baggedBased = genes_treebag_baggedBased[[1]],
genes_gamboost_boostBased = genes_gamboost_boostBased[[1]],
genes_bstSm_boostBased = genes_bstSm_boostBased[[1]],
genes_bstTree_boostBased = genes_bstTree_boostBased[[1]],
genes_gpls_plsBased = genes_gpls_plsBased[[1]],
# genes_pls_plsBased = genes_pls_plsBased[[1]],
genes_spls_plsBased = genes_spls_plsBased[[1]])
saveRDS(list_genes, paste0("../Results/list_genes_",i,".rds"))
return(list(acc.df, list_genes))
}
i = 1
cv <- 10
for (i in c(1:cv)) {
print(paste0("Performing Cross-Validation of ",i," layer"))
crossVal.1layer(seed = i, i = i, mincorr = 0.35)
}
warnings()
library(ggplot2)
df1 <- read.csv2(paste0("../Results/AccuracyTable_1.csv"))
df2 <- read.csv2(paste0("../Results/AccuracyTable_2.csv"))
df3 <- read.csv2(paste0("../Results/AccuracyTable_3.csv"))
df4 <- read.csv2(paste0("../Results/AccuracyTable_4.csv"))
df5 <- read.csv2(paste0("../Results/AccuracyTable_5.csv"))
df6 <- read.csv2(paste0("../Results/AccuracyTable_6.csv"))
df7 <- read.csv2(paste0("../Results/AccuracyTable_7.csv"))
df8 <- read.csv2(paste0("../Results/AccuracyTable_8.csv"))
df9 <- read.csv2(paste0("../Results/AccuracyTable_9.csv"))
df10 <- read.csv2(paste0("../Results/AccuracyTable_10.csv"))
View(df1)
df1$Group <- c(rep("SVM-based",each=3), rep("voom-based",each=3),
rep("LDA-based",each=4), #rep("NNet-based",each=2),
rep("Tree-based",each=4), rep("Bagged",each=3),
rep("Boosted",each=3), rep("PLS-based",each=3))
View(df1)
df2$Group <- c(rep("SVM-based",each=3), rep("voom-based",each=3),
rep("LDA-based",each=4), #rep("NNet-based",each=2),
rep("Tree-based",each=4), rep("Bagged",each=3),
rep("Boosted",each=3), rep("PLS-based",each=3))
df3$Group <- c(rep("SVM-based",each=3), rep("voom-based",each=3),
rep("LDA-based",each=4), #rep("NNet-based",each=2),
rep("Tree-based",each=4), rep("Bagged",each=3),
rep("Boosted",each=3), rep("PLS-based",each=3))
df4$Group <- c(rep("SVM-based",each=3), rep("voom-based",each=3),
rep("LDA-based",each=4), #rep("NNet-based",each=2),
rep("Tree-based",each=4), rep("Bagged",each=3),
rep("Boosted",each=3), rep("PLS-based",each=3))
df5$Group <- c(rep("SVM-based",each=3), rep("voom-based",each=3),
rep("LDA-based",each=4), #rep("NNet-based",each=2),
rep("Tree-based",each=4), rep("Bagged",each=3),
rep("Boosted",each=3), rep("PLS-based",each=3))
df6$Group <- c(rep("SVM-based",each=3), rep("voom-based",each=3),
rep("LDA-based",each=4), #rep("NNet-based",each=2),
rep("Tree-based",each=4), rep("Bagged",each=3),
rep("Boosted",each=3), rep("PLS-based",each=3))
df7$Group <- c(rep("SVM-based",each=3), rep("voom-based",each=3),
rep("LDA-based",each=4), #rep("NNet-based",each=2),
rep("Tree-based",each=4), rep("Bagged",each=3),
rep("Boosted",each=3), rep("PLS-based",each=3))
df8$Group <- c(rep("SVM-based",each=3), rep("voom-based",each=3),
rep("LDA-based",each=4), #rep("NNet-based",each=2),
rep("Tree-based",each=4), rep("Bagged",each=3),
rep("Boosted",each=3), rep("PLS-based",each=3))
df9$Group <- c(rep("SVM-based",each=3), rep("voom-based",each=3),
rep("LDA-based",each=4), #rep("NNet-based",each=2),
rep("Tree-based",each=4), rep("Bagged",each=3),
rep("Boosted",each=3), rep("PLS-based",each=3))
df10$Group <- c(rep("SVM-based",each=3), rep("voom-based",each=3),
rep("LDA-based",each=4), #rep("NNet-based",each=2),
rep("Tree-based",each=4), rep("Bagged",each=3),
rep("Boosted",each=3), rep("PLS-based",each=3))
df <- do.call("rbind", list(df1, df2, df3, df4, df5, df6, df7, df8, df9, df10))
ggplot(df, aes(x = as.factor(X), y = Accuracy, fill = as.factor(Group))) +
geom_boxplot() +
geom_point() +
scale_fill_brewer(palette = c("Paired")) +
theme_minimal() +
theme(axis.text.x = element_text(angle = 45, hjust = 1, face = "bold"))
ggplot(df, aes(x = as.factor(X), y = Precision, fill = as.factor(Group))) +
geom_boxplot() +
geom_point() +
scale_fill_brewer(palette = c("Paired")) +
theme_minimal()+
theme(axis.text.x = element_text(angle = 45, hjust = 1, face = "bold"))
ggplot(df, aes(x = as.factor(X), y = Recall, fill = as.factor(Group))) +
geom_boxplot() +
geom_point() +
scale_fill_brewer(palette = c("Paired")) +
theme_minimal()+
theme(axis.text.x = element_text(angle = 45, hjust = 1, face = "bold"))
ggplot(df, aes(x = as.factor(X), y = Balanced.Accuracy, fill = as.factor(Group))) +
geom_boxplot() +
geom_point() +
scale_fill_brewer(palette = c("Paired")) +
theme_minimal()+
theme(axis.text.x = element_text(angle = 45, hjust = 1, face = "bold"))
Upset_plot_no_merge <- function(lista_geni) {
# Carica il pacchetto tidyverse
library(tidyverse)
#Carico il pacchetto Upset
library(UpSetR)
# Estrai tutti i geni unici di tutti gli algoritmi
geni_unici <- sort(unique(unlist(lista_geni)))
# Crea un dataframe vuoto
df <- data.frame(RowName = names(lista_geni))
# Aggiungi colonne per ogni gene unico e assegna TRUE o FALSE in base alla presenza del gene
for (gene in geni_unici) {
df[[gene]] <- map_lgl(df$RowName, ~ gene %in% lista_geni[[.x]])
}
# Imposta i nomi delle righe uguali al nome dell'algoritmo
rownames(df) <- df$RowName
df$RowName <- NULL
df <- as.data.frame(t(df))
df <- as.data.frame(ifelse(df == "TRUE", 1, 0))
print(upset(df, nsets = ncol(df), nintersects = nrow(df), mb.ratio = c(0.5, 0.5),
color.pal = 1, sets.bar.color = "lightblue"))
}
a <- readRDS(file = "../Results/list_genes_1.rds")
Upset_plot_no_merge(a)
b <- readRDS(file = "../Results/list_genes_2.rds")
c <- readRDS(file = "../Results/list_genes_3.rds")
d <- readRDS(file = "../Results/list_genes_4.rds")
e <- readRDS(file = "../Results/list_genes_5.rds")
f <- readRDS(file = "../Results/list_genes_6.rds")
g <- readRDS(file = "../Results/list_genes_7.rds")
h <- readRDS(file = "../Results/list_genes_8.rds")
i <- readRDS(file = "../Results/list_genes_9.rds")
j <- readRDS(file = "../Results/list_genes_10.rds")
Upset_plot_no_merge(a)
Upset_plot_no_merge(b)
Upset_plot_no_merge(c)
Upset_plot_no_merge(d)
Upset_plot_no_merge(e)
Upset_plot_no_merge(f)
Upset_plot_no_merge(g)
Upset_plot_no_merge(h)
Upset_plot_no_merge(i)
Upset_plot_no_merge(j)
Upset_plot_no_merge(a)
Upset_plot_no_merge <- function(lista_geni) {
# Carica il pacchetto tidyverse
library(tidyverse)
#Carico il pacchetto Upset
library(UpSetR)
# Estrai tutti i geni unici di tutti gli algoritmi
geni_unici <- sort(unique(unlist(lista_geni)))
# Crea un dataframe vuoto
df <- data.frame(RowName = names(lista_geni))
# Aggiungi colonne per ogni gene unico e assegna TRUE o FALSE in base alla presenza del gene
for (gene in geni_unici) {
df[[gene]] <- map_lgl(df$RowName, ~ gene %in% lista_geni[[.x]])
}
# Imposta i nomi delle righe uguali al nome dell'algoritmo
rownames(df) <- df$RowName
df$RowName <- NULL
df <- as.data.frame(t(df))
df <- as.data.frame(ifelse(df == "TRUE", 1, 0))
print(upset(df, nsets = ncol(df), nintersects = nrow(df), mb.ratio = c(0.5, 0.5),
color.pal = 1, sets.bar.color = "lightblue"),
attribute.plots = list(gridrows = nrow(df),
plots = list(list(plot = histogram, x = "ReleaseDate", queries = F), list(plot = histogram,
x = "AvgRating", queries = T)), ncols = 2))
}
Upset_plot_no_merge(a)
Upset_plot_no_merge(b)
Upset_plot_no_merge(c)
Upset_plot_no_merge <- function(lista_geni) {
# Carica il pacchetto tidyverse
library(tidyverse)
#Carico il pacchetto Upset
library(UpSetR)
# Estrai tutti i geni unici di tutti gli algoritmi
geni_unici <- sort(unique(unlist(lista_geni)))
# Crea un dataframe vuoto
df <- data.frame(RowName = names(lista_geni))
# Aggiungi colonne per ogni gene unico e assegna TRUE o FALSE in base alla presenza del gene
for (gene in geni_unici) {
df[[gene]] <- map_lgl(df$RowName, ~ gene %in% lista_geni[[.x]])
}
# Imposta i nomi delle righe uguali al nome dell'algoritmo
rownames(df) <- df$RowName
df$RowName <- NULL
df <- as.data.frame(t(df))
df <- as.data.frame(ifelse(df == "TRUE", 1, 0))
print(upset(df, nsets = ncol(df), nintersects = nrow(df),
color.pal = 1, sets.bar.color = "lightblue"),
attribute.plots = list(gridrows = nrow(df),
plots = list(list(plot = histogram, x = "ReleaseDate", queries = F), list(plot = histogram,
x = "AvgRating", queries = T)), ncols = 2))
}
Upset_plot_no_merge(a)
Upset_plot_no_merge <- function(lista_geni) {
# Carica il pacchetto tidyverse
library(tidyverse)
#Carico il pacchetto Upset
library(UpSetR)
# Estrai tutti i geni unici di tutti gli algoritmi
geni_unici <- sort(unique(unlist(lista_geni)))
# Crea un dataframe vuoto
df <- data.frame(RowName = names(lista_geni))
# Aggiungi colonne per ogni gene unico e assegna TRUE o FALSE in base alla presenza del gene
for (gene in geni_unici) {
df[[gene]] <- map_lgl(df$RowName, ~ gene %in% lista_geni[[.x]])
}
# Imposta i nomi delle righe uguali al nome dell'algoritmo
rownames(df) <- df$RowName
df$RowName <- NULL
df <- as.data.frame(t(df))
df <- as.data.frame(ifelse(df == "TRUE", 1, 0))
print(upset(df, nsets = ncol(df), nintersects = nrow(df),
color.pal = 1, sets.bar.color = "lightblue",
attribute.plots = list(gridrows = nrow(df),
plots = list(list(plot = histogram, x = "ReleaseDate", queries = F),
list(plot = histogram,x = "AvgRating", queries = T)), ncols = 2)))
}
Upset_plot_no_merge(a)
View(df1)
View(a)
lista_geni <- a
# Estrai tutti i geni unici di tutti gli algoritmi
geni_unici <- sort(unique(unlist(lista_geni)))
# Crea un dataframe vuoto
df <- data.frame(RowName = names(lista_geni))
# Aggiungi colonne per ogni gene unico e assegna TRUE o FALSE in base alla presenza del gene
for (gene in geni_unici) {
df[[gene]] <- map_lgl(df$RowName, ~ gene %in% lista_geni[[.x]])
}
# Imposta i nomi delle righe uguali al nome dell'algoritmo
rownames(df) <- df$RowName
df$RowName <- NULL
df <- as.data.frame(t(df))
df <- as.data.frame(ifelse(df == "TRUE", 1, 0))
View(df)
print(upset(df, nsets = ncol(df), nintersects = nrow(df),
color.pal = 1, sets.bar.color = "lightblue",
attribute.plots = list(gridrows = nrow(df),
plots = list(list(plot = histogram, x = rownames(df), queries = F)))))
print(upset(df, nsets = ncol(df), nintersects = nrow(df),
color.pal = 1, sets.bar.color = "lightblue"))
Upset_plot_no_merge <- function(lista_geni) {
# Carica il pacchetto tidyverse
library(tidyverse)
#Carico il pacchetto Upset
library(UpSetR)
# Estrai tutti i geni unici di tutti gli algoritmi
geni_unici <- sort(unique(unlist(lista_geni)))
# Crea un dataframe vuoto
df <- data.frame(RowName = names(lista_geni))
# Aggiungi colonne per ogni gene unico e assegna TRUE o FALSE in base alla presenza del gene
for (gene in geni_unici) {
df[[gene]] <- map_lgl(df$RowName, ~ gene %in% lista_geni[[.x]])
}
# Imposta i nomi delle righe uguali al nome dell'algoritmo
rownames(df) <- df$RowName
df$RowName <- NULL
df <- as.data.frame(t(df))
df <- as.data.frame(ifelse(df == "TRUE", 1, 0))
print(upset(df, nsets = ncol(df), nintersects = nrow(df),
color.pal = 1, sets.bar.color = "lightblue"))
}
print(upset(df, nsets = ncol(df), nintersects = nrow(df),
color.pal = 1, sets.bar.color = "lightblue",
mb.ratio = c(0.6,0.4)))
print(upset(df, nsets = ncol(df), nintersects = nrow(df),
color.pal = 1, sets.bar.color = "lightblue",
mb.ratio = c(0.4,0.6)))
ggplot(df, aes(x = as.factor(X), y = Accuracy, fill = as.factor(Group))) +
geom_boxplot() +
geom_point() +
scale_fill_brewer(palette = c("Paired")) +
theme_minimal() +
theme(axis.text.x = element_text(angle = 45, hjust = 1, face = "bold"))
a
a
a
a
a
a
a
a
a
df1 <- read.csv2(paste0("../Results/AccuracyTable_1.csv"))
df2 <- read.csv2(paste0("../Results/AccuracyTable_2.csv"))
df3 <- read.csv2(paste0("../Results/AccuracyTable_3.csv"))
df4 <- read.csv2(paste0("../Results/AccuracyTable_4.csv"))
df5 <- read.csv2(paste0("../Results/AccuracyTable_5.csv"))
df6 <- read.csv2(paste0("../Results/AccuracyTable_6.csv"))
df7 <- read.csv2(paste0("../Results/AccuracyTable_7.csv"))
df8 <- read.csv2(paste0("../Results/AccuracyTable_8.csv"))
df9 <- read.csv2(paste0("../Results/AccuracyTable_9.csv"))
df10 <- read.csv2(paste0("../Results/AccuracyTable_10.csv"))
df1$Group <- c(rep("SVM-based",each=3), rep("voom-based",each=3),
rep("LDA-based",each=4), #rep("NNet-based",each=2),
rep("Tree-based",each=4), rep("Bagged",each=3),
rep("Boosted",each=3), rep("PLS-based",each=3))
df2$Group <- c(rep("SVM-based",each=3), rep("voom-based",each=3),
rep("LDA-based",each=4), #rep("NNet-based",each=2),
rep("Tree-based",each=4), rep("Bagged",each=3),
rep("Boosted",each=3), rep("PLS-based",each=3))
df3$Group <- c(rep("SVM-based",each=3), rep("voom-based",each=3),
rep("LDA-based",each=4), #rep("NNet-based",each=2),
rep("Tree-based",each=4), rep("Bagged",each=3),
rep("Boosted",each=3), rep("PLS-based",each=3))
df4$Group <- c(rep("SVM-based",each=3), rep("voom-based",each=3),
rep("LDA-based",each=4), #rep("NNet-based",each=2),
rep("Tree-based",each=4), rep("Bagged",each=3),
rep("Boosted",each=3), rep("PLS-based",each=3))
df5$Group <- c(rep("SVM-based",each=3), rep("voom-based",each=3),
rep("LDA-based",each=4), #rep("NNet-based",each=2),
rep("Tree-based",each=4), rep("Bagged",each=3),
rep("Boosted",each=3), rep("PLS-based",each=3))
df6$Group <- c(rep("SVM-based",each=3), rep("voom-based",each=3),
rep("LDA-based",each=4), #rep("NNet-based",each=2),
rep("Tree-based",each=4), rep("Bagged",each=3),
rep("Boosted",each=3), rep("PLS-based",each=3))
df7$Group <- c(rep("SVM-based",each=3), rep("voom-based",each=3),
rep("LDA-based",each=4), #rep("NNet-based",each=2),
rep("Tree-based",each=4), rep("Bagged",each=3),
rep("Boosted",each=3), rep("PLS-based",each=3))
df8$Group <- c(rep("SVM-based",each=3), rep("voom-based",each=3),
rep("LDA-based",each=4), #rep("NNet-based",each=2),
rep("Tree-based",each=4), rep("Bagged",each=3),
rep("Boosted",each=3), rep("PLS-based",each=3))
df9$Group <- c(rep("SVM-based",each=3), rep("voom-based",each=3),
rep("LDA-based",each=4), #rep("NNet-based",each=2),
rep("Tree-based",each=4), rep("Bagged",each=3),
rep("Boosted",each=3), rep("PLS-based",each=3))
df10$Group <- c(rep("SVM-based",each=3), rep("voom-based",each=3),
rep("LDA-based",each=4), #rep("NNet-based",each=2),
rep("Tree-based",each=4), rep("Bagged",each=3),
rep("Boosted",each=3), rep("PLS-based",each=3))
df <- do.call("rbind", list(df1, df2, df3, df4, df5, df6, df7, df8, df9, df10))
ggplot(df, aes(x = as.factor(X), y = Accuracy, fill = as.factor(Group))) +
geom_boxplot() +
geom_point() +
scale_fill_brewer(palette = c("Paired")) +
theme_minimal() +
theme(axis.text.x = element_text(angle = 45, hjust = 1, face = "bold"))
